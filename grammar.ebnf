program
    = { decl }
    ;

decl
    = valdecl
    | typedecl
    ;

valdecl
    = "let", identifier, [ template_params ], valdecl_content
    ;

valdecl_content
    = "(" [ param { ",", param } ], ")", type, stmtblock  (* function *)
    | [ type_annotation ], [ "=", valexpr ]               (* variable *)
    ;

param
    = identifier, ":", type
    ;

typedecl
    = "type", identifier, [ template_params ], typedecl_content, [ where_clause ]
    ;

typedecl_content
    = "=", type                              (* alias *)
    | "{", { decl }, "}"                     (* struct *)
    | "|", variant, { "|", variant }         (* union *)
    ;

variant
    = identifier, [ "(", type, { ",", type }, ")" ]
    ;

where_clause
    = "where", "{", { decl }, "}"
    ;

template_params
    = "!", "(", template_param, { ",", template_param }, ")"
    ;

template_param
    = identifier
    | identifier, ":", type
    ;

type_annotation
    = ":", type
    ;

type
    = primitivetype
    | pointertype
    | arraytype
    | aliastype
    | functiontype
    | template_instantiation
    ;

template_instantiation
    = identifier, "!", "(", type, { ",", type }, ")"
    ;

primitivetype
    = ? primitive types ?
    ;

pointertype
    = "*", type
    ;

arraytype
    = "[]", type
    ;

aliastype
    = identifier
    ;

functiontype
    = "(", [ type, { ",", type } ], ")", type
    ;

stmtblock
    = "{"
    , { stmt }
    , "}"
    ;

stmt
    = decl
    | valexpr
    | ifthen
    | loop
    ;

ifthen
    = "if", "(", valexpr, ")"
    , stmtblock
    , [ "else", ( ifthen | stmtblock ) ]
    ;

loop
    = "while", "(", valexpr, ")"
    , stmtblock
    ;

valexpr
    = valexpr, binop, valexpr
    | lvalexpr
    | literal
    ;

binop
    = ? binary operations ?
    ;

lvalexpr
    = prefixop, lvalexpr
    | unitexpr
    ;

prefixop
    = ? prefix operations ?
    ;

unitexpr
    = unitexpr, postop
    | unitexpr, "(", [ valexpr, { ",", valexpr } ], ")"  (* call *)
    | unitexpr, "[", valexpr, "]"                        (* subscript *)
    | unitexpr, "as", type                               (* cast *)
    | "(", valexpr, ")"                                  (* paren *)
    | identifier                                         (* ref *)
    ;

postop
    = ? postfix operations ?
    ;

identifier
    = alphachar, { alphachar | numchar }
    ;

literal
    = '"', { printchar }, '"'                 (* string *)
    | "'", [ printchar ], "'"                 (* char *)
    | numchar, [ alphachar ], { numchar }     (* integral *)
    | { numchar }, ".", numchar, { numchar }  (* floating point *)
    ;

printchar
    = alphachar
    | numchar
    | ? type-able characters other than \ ' " ?
    | "\", ? escape code characters (including \ ' ") ?
    ;

alphachar
    = ? alphabetic characters or underscore ?
    ;

numchar
    = ? numeric characters ?
    ;
