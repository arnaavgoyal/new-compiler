program
    = { bind }
    ;

stmtblock
    = "{", { stmt }, "}"
    ;

stmt
    = bind
    | expr
    ;

bind
    = "let", [ meta ], identifier, [ type_annotation ], "=", expr
    ;

meta
    = "!"

type_annotation
    = ":", expr
    ;

expr
    = "type" typedecl
    | branch
    | loop
    | func
    | binaryexpr
    ;

typedecl
    = ( struct | union ), [ "where", "{", { bind }, "}" ]
    ;

struct
    = "{", { identifier, type_annotation }, "}"
    ;

union
    = "|", variant, { "|", variant }
    ;

variant
    = identifier, [ "(", expr, { ",", expr }, ")" ]
    ;

branch
    = "if", [ meta ], expr, stmtblock, [ "else", ( branch | stmtblock ) ]
    ;

loop
    = "while", [ meta ], expr, stmtblock
    ;

func
    = "fn", [ meta ], [ captures ], params, type_annotation, stmtblock
    ;

captures
    = "[", capture, { ",", capture }, "]"
    ;

capture
    = "&", identifier
    | identifier
    ;

params
    = "(", identifier, type_annotation, { ",", identifier, type_annotation }, ")"
    ;

binaryexpr
    = binaryexpr, binop, prefixexpr  (* not all binops are left-assoc *)
    | prefixexpr
    ;

prefixexpr
    = prefixop, prefixexpr
    | primaryexpr, [ postfixexpr ]
    ;

prefixop
    = ? prefix operators ?
    ;

primaryexpr
    = "(", expr, ")"
    | identifier
    | literal
    ;

postfixexpr
    = postfixexpr, call_postfix       (* call *)
    | postfixexpr, "[", expr, "]"     (* subscript *)
    | postfixexpr, "as", expr         (* cast *)
    | postfixexpr, ".", identifier    (* scope open / member access *)
    | postfixexpr, "->", prefixexpr   (* only for function types *)
    | postfixexpr, postfixop
    ;

call_postfix
    = [ meta ], "(", [ expr, { ",", expr } ], ")"
    ;

postfixop
    = ? postfix operators ?
    ;

binop
    = ? binary operators ?
    ;

identifier
    = alphachar, { alphachar | numchar }
    ;

literal
    = '"', { printchar }, '"'                 (* string *)
    | "'", [ printchar ], "'"                 (* char *)
    | numchar, [ alphachar ], { numchar }     (* integral *)
    | { numchar }, ".", numchar, { numchar }  (* float *)
    ;

printchar
    = alphachar
    | numchar
    | ? other printable characters ?
    | "\", ? escape code ?
    ;

alphachar
    = ? alphabetic characters or underscore ?
    ;

numchar
    = ? numeric characters ?
    ;
