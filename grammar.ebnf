program
    = { decl }
    ;

decl
    = valdecl
    | typedecl
    ;

valdecl
    = "let", identifier, [ template_params ], valdecl_content
    ;

valdecl_content
    = "(", [ param { ",", param } ], ")", type_annotation, stmtblock
    | [ type_annotation ], [ "=", expr ]
    ;

param
    = identifier, ":", expr
    ;

typedecl
    = "type", identifier, [ template_params ], typedecl_content, [ where_clause ]
    ;

typedecl_content
    = "=", expr
    | "{", { decl }, "}"
    | "|", variant, { "|", variant }
    ;

variant
    = identifier, [ "(", expr, { ",", expr }, ")" ]
    ;

where_clause
    = "where", "{", { decl }, "}"
    ;

template_params
    = "!", "(", template_param, { ",", template_param }, ")"
    ;

template_param
    = identifier
    | identifier, ":", expr
    ;

type_annotation
    = ":", expr
    ;

stmtblock
    = "{", { stmt }, "}"
    ;

stmt
    = decl
    | expr
    | ifthen
    | loop
    ;

ifthen
    = "if", "(", expr, ")", stmtblock,
      [ "else", ( ifthen | stmtblock ) ]
    ;

loop
    = "while", "(", expr, ")", stmtblock
    ;

expr
    = binaryexpr
    ;

binaryexpr
    = binaryexpr, binop, unaryexpr
    | unaryexpr
    ;

unaryexpr
    = prefixop, unaryexpr
    | postfixexpr
    ;

postfixexpr
    = postfixexpr, "(", [ expr, { ",", expr } ], ")"
    | postfixexpr, "[", expr, "]"
    | postfixexpr, "as", expr
    | primaryexpr
    ;

primaryexpr
    = "(", expr, ")"
    | identifier
    | literal
    ;

prefixop
    = "*"
    | "[]"
    | ? other prefix operators ?
    ;

binop
    = ? binary operators ?
    ;

identifier
    = alphachar, { alphachar | numchar }
    ;

literal
    = '"', { printchar }, '"'
    | "'", [ printchar ], "'"
    | numchar, [ alphachar ], { numchar }
    | { numchar }, ".", numchar, { numchar }
    ;

printchar
    = alphachar
    | numchar
    | ? other printable characters ?
    | "\", ? escape code ?
    ;

alphachar
    = ? alphabetic characters or underscore ?
    ;

numchar
    = ? numeric characters ?
    ;

(*  TYPE EXPRS - this is not relevant to parsing, but to semantics  *)

expr = type_expr | val_expr
val_expr = ...
type_expr = ptr | slice | func | type
ptr = "*", type_expr
slice = "[]", type_expr
func = "(", [ type_expr { ",", type_expr } ], ")", "->", type_expr
type = identifier, [ tmplargs ], [ ".", type ]
tmplargs = "!", "(", [ expr { ",", expr } ], ")"
