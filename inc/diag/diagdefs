#ifndef DIAGNOSTIC
#define DIAGNOSTIC(name, severity, str)
#endif

// syntax

DIAGNOSTIC(expected_declaration_in_non_execution_context, error, "expected declaration (top level scope is not a valid execution context)")
DIAGNOSTIC(non_declaration_in_non_execution_scope, error, "only declarations are allowed at top level and in where-clauses (found %0)")
DIAGNOSTIC(expected_expression, error, "expected expression")
DIAGNOSTIC(expected_token, error, "expected '%0'")
DIAGNOSTIC(expected_type, error, "expected type expression")
DIAGNOSTIC(decl_expected_identifier, fatal, "expected identifier for declaration")
DIAGNOSTIC(expected_type_annotation, error, "expected type annotation")
DIAGNOSTIC(type_decl_expected_assignment, fatal, "expected '=' after type declaration")

// semantic

// decls
DIAGNOSTIC(symbol_redeclaration, error, "redeclaration of symbol '%0'")
DIAGNOSTIC(note_original_declaration, note, "original declaration here:")
DIAGNOSTIC(ref_undeclared_symbol, error, "use of undeclared symbol '%0'")
DIAGNOSTIC(recursive_type_definition, error, "recursive type definition detected for '%0'")
DIAGNOSTIC(note_recursive_type_reference, note, "type '%0' is part of a recursive definition")
DIAGNOSTIC(type_cycle_detected, error, "detected type cycle %0")
DIAGNOSTIC(note_type_requires, note, "%0 requires %1")

// template instantiation cycles
DIAGNOSTIC(template_instantiation_cycle_detected, error, "detected type cycle during template instantiation: %0")
DIAGNOSTIC(note_template_instantiation, note, "in instantiation of '%0' requested here")
DIAGNOSTIC(note_template_dependency, note, "'%0' requires '%1' here")
DIAGNOSTIC(expected_type_found_symbol, error, "expected type '%0' but found symbol instead")
DIAGNOSTIC(expected_symbol_found_type, error, "expected symbol '%0' but found type instead")
DIAGNOSTIC(pointer_to_function_type_invalid, error, "pointer to function is not a valid type")
DIAGNOSTIC(type_is_not_templated, error, "type '%0' is not a templated type")

// expr universes
DIAGNOSTIC(operator_not_allowed_in_type_expr, error, "operator '%0' not allowed in a type context")
DIAGNOSTIC(operator_not_allowed_in_value_expr, error, "operator '%0' not allowed in a value context")

// call exprs
DIAGNOSTIC(noncallable_expression, error, "expression is not callable (type is '%0')")
DIAGNOSTIC(call_expr_too_few_arguments, error, "too few arguments to function of type '%2' (expected %0, got %1)")
DIAGNOSTIC(call_expr_too_many_arguments, error, "too many arguments to function of type '%2' (expected %0, got %1)")
DIAGNOSTIC(call_expr_typecheck_argument, error, "argument type mismatch (expected '%0', got '%1')")

// ref exprs
DIAGNOSTIC(use_of_undeclared_symbol, error, "use of undeclared symbol '%0'")

// indirection
DIAGNOSTIC(indirection_typecheck, error, "indirection requires operand of pointer type (got '%0')")

// address-of
DIAGNOSTIC(address_of_typecheck, error, "address-of requires lvalue operand (got rvalue of type '%0')")

// logical not
DIAGNOSTIC(logical_not_typecheck, error, "logical not requires operand of integral type (got '%0')")

// unary negate
DIAGNOSTIC(unary_negate_typecheck, error, "unary negate requires operand of integral type (got '%0')")

// side-effecting unary ops (pre/postfix incr/decrement)
DIAGNOSTIC(side_effecting_unary_typecheck_lvalue, error, "pre/postfix incr/decrement requires lvalue operand (got rvalue of type '%0')")
DIAGNOSTIC(side_effecting_unary_typecheck_integral, error, "pre/postfix incr/decrement requires operand of integral type (got '%0')")

// binary operators
DIAGNOSTIC(binary_op_typecheck, error, "incompatible operands to binary operator '%0' ('%1' and '%2')")
DIAGNOSTIC(arrow_only_in_type_expr, error, "arrow operator '->' can only be used in type expressions, not value expressions")
DIAGNOSTIC(invalid_operation_on_type, error, "this operation cannot be applied to type expressions")
DIAGNOSTIC(subscript_on_type, error, "subscript operator '[]' cannot be applied to type expressions")
DIAGNOSTIC(dot_on_non_field_accessible_type, error, "dot operator '.' cannot be applied to non field-accessible type ('%0')")
DIAGNOSTIC(call_on_type, error, "call operator '()' cannot be applied to type expressions")

// assignment typecheck
DIAGNOSTIC(warn_assignment_signed_to_unsigned, warning, "value of signed type '%0' assigned to unsigned type '%1'")
DIAGNOSTIC(warn_assignment_unsigned_to_signed, warning, "value of unsigned type '%0' assigned to signed type '%1'")
DIAGNOSTIC(warn_assignment_implicit_upcast, warning, "value of type '%0' assigned to larger type '%1'")
DIAGNOSTIC(warn_assignment_pointer_to_pointer_cast, warning, "value of pointer type '%0' assigned to different pointer type '%1'")
DIAGNOSTIC(assignment_requires_explicit_downcast, error, "assignment requires explicit truncating cast of value to '%0' from '%1'")

// integral literals
DIAGNOSTIC(integral_literal_too_big, error, "integral literal '%0' is too large for any integral type")

// meta (compile-time) evaluation
DIAGNOSTIC(meta_depends_on_runtime, error, "compile-time expression depends on runtime value '%0'")
DIAGNOSTIC(note_meta_dependency, note, "in dependency of compile-time binding '%0'")
DIAGNOSTIC(meta_cycle_detected, error, "cycle detected in compile-time dependencies: %0")
DIAGNOSTIC(note_meta_cycle_node, note, "'%0' depends on '%1' here")

// expression universe validation
DIAGNOSTIC(type_only_operator_in_value_context, error, "operator '%0' is only valid in type expressions")
DIAGNOSTIC(value_only_operator_in_type_context, error, "operator '%0' is only valid in value expressions")
DIAGNOSTIC(type_used_in_value_context, error, "type '%0' cannot be used in a value expression")
DIAGNOSTIC(value_used_in_type_context, error, "value '%0' cannot be used in a type expression")
DIAGNOSTIC(meta_expr_type_mismatch, error, "meta expression returns %0 but %1 is expected")
DIAGNOSTIC(if_meta_branch_type_mismatch, error, "if! branches return different universes (then: %0, else: %1)")
DIAGNOSTIC(while_meta_not_allowed_in_type, error, "while! loop cannot be used in type context (use if! instead)")

// constant evaluation
DIAGNOSTIC(const_eval_not_compile_time, error, "expression is not evaluable at compile time")
DIAGNOSTIC(const_eval_division_by_zero, error, "division by zero in constant expression")
DIAGNOSTIC(const_eval_overflow, error, "overflow in constant expression")

// type checking
DIAGNOSTIC(branch_type_mismatch, error, "if branches have incompatible types (then: '%0', else: '%1')")
DIAGNOSTIC(return_type_mismatch, error, "function body type '%0' does not match declared return type '%1'")

// dev

DIAGNOSTIC(deprecated, error, "%0 are deprecated")
DIAGNOSTIC(nyi, error, "%0 are not yet implemented")

#undef DIAGNOSTIC
