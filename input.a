let main = fn(): i32 {
    let x: i32 = 5
    let y = 10
    let z = x + y * 2
//  let x = 2
    
    if (x) {
        let nested: i32 = 100
        nested
    }
    else {
        0
    }
}

// valid
let! Node = fn!(T: type): type {
    type as Self {
        val: T
        next: *Self
    }
}

// valid
let! Option = fn!(T: type): type {
    type
        | Some(T)
        | None
}
let! Vector = fn!(T: type): type {
    type as Self {
        data: *T
        size: i32
    } where {
        let new = fn(): Self {
            let v: Self
            v
        }
    }
}
let! IntOptVec = Vector!(Option!(i32))

// Test namespace access on a named type alias
let vec_test = IntOptVec.new()

// valid - with where clause
let! Array = fn!(T: type, N: u32): type {
    type as Self {
        data: []T
        size: u32
    } where {
        let init = fn(): Self {
            let arr: Self
            arr
        }
    }
}

// With where clause - test later
// let! ArrayWithInit = fn!(T: type, N: u32): type {
//     type as Self {
//         data: []T
//         size: u32
//     } where {
//         let init = fn(): Self {
//             let arr: Self
//             arr.size = N
//             arr
//         }
//     }
// }

// Compile-time conditional example using if!
let! MaybePointer = fn!(T: type, AsPtr: u32): type {
    if! (AsPtr) {
        *T
    }
    else {
        T
    }
}

// Tests: these should evaluate at compile time
let! PtrInt = MaybePointer!(i32, 1)   // Should be *i32
let! ValInt = MaybePointer!(i32, 0)   // Should be i32

// Compile-time constant evaluation
let! SIZE = 42
let! IS_BIG = SIZE > 30  // Should evaluate to 1 (true)

// Type intrinsic tests - note the ! suffix for meta calls
let! IS_PTR_TEST = _is_pointer!(*i32)    // Should be 1
let! IS_NOT_PTR = _is_pointer!(i32)      // Should be 0
let! PTR_SIZE = _sizeof!(*i32)           // Should be 8

// Meta function that returns a value based on type comparison
let! cxx_template_var = fn!(T: type): i32 {
    // Use if! for compile-time type comparison
    if! (T == i32) { 1 }
    else { 2 }
}

// Top-level meta expressions must evaluate to bindings
// This if! evaluates cxx_template_var!(i64) which returns 2,
// so 2 == 1 is false, and the else branch is taken
if! cxx_template_var!(i64) == 1 {
    let x = 4
}
else {
    let x = 5
}

let! dispatch_fn = fn!(T: type): type {
    if! (T == u8) { u16 }
    else if! (T == u16) { u32 }
    else { i64 }
}

let! specialized = fn!(T: type, f: (type) -> type): type {
    Vector!(f!(T))
}
// spec_test type should resolve to Vector!(u32)
let! spec_test = specialized!(u16, dispatch_fn)

// Instantiate Array type first, then access its namespace
let arr = Array!(i32, 6).init()

// Test simple namespace access
let! ArrayTest = Array!(i32, 6)

// Test let without initializer (just type annotation)
let uninit_var: i32

let Base = type as Self {
    x: i32
} where {
    let init = fn(): Self {
        let b: Base
        b.x = 3
        b
    }
}
let base = Base.init()

// // invalid - cyclical dependency
// let! BadNode = fn!(T: type): type {
//     type as Me {
//         x: Me
//     }
// }
// 
// // also invalid
// let! Outer = fn!(T: type): type {
//     type {
//         x: Internal
//     } where {
//         let! Internal = fn!(T: type): type {
//             type as Self {
//                 x: Outer!(T)
//             }
//         }
//     }
// }
// 
// // valid, but infinite recursion must be caught during evaluation
// let! A = fn!(f: (type) -> type): type {
//     A(f)
// }
// 
// // invalid - but would this be caught now or later?
// let! MutRec1 = fn!(f: (type) -> type) : type {
//     MutRec2!(f)
// }
// let! MutRec2 = fn!(f: (type) -> type) : type {
//     MutRec1!(f)
// }

let loop_test = fn(n: i32): i32 {
    while (n) {
        let x = n - 1
        0
    }
}

let lambda_test = fn(f: (i32) -> i32): i32 {
    let identity = fn(x: i32): i32 { x }
    identity(5)
}
 