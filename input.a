type Node!(T) {
    val: T
    next: *Node!(T)
}

type BadNode!(T) {
    val: T
    next: BadNode!(T)
}

// namespacing test
type Namespace {
    x: Internal
} where {
    type Internal
        | Some(Internal2)
        | None
    where {
        type Internal2 = Namespace
    }
}

let foo(fn: (i32) -> *i32): *i32 {
    fn(0)
}

let main(): i32 {
    []x.y.z
    let test_invalid_annot: i32 + 3
    let head: *Node!(i32)
    head.val = *foo(\(x: i32): *i32 { 0 })
    let x = 3 * 4 + 6
    type Foo = Namespace.Internal.Internal2+2
    if (head) {
        head.val
    }
    else {
        0
    }
}


// ─────────────────────────────────────────────
// 1. Simple alias chain (invalid cycle)
// ─────────────────────────────────────────────

// type A1 = B1
// type B1 = C1
// type C1 = A1
// 
// 
// // ─────────────────────────────────────────────
// // 2. Pointer-broken self recursion (valid)
// // ─────────────────────────────────────────────
// 
// type Node2 {
//     next: *Node2
// }
// 
// 
// // ─────────────────────────────────────────────
// // 3. Struct ↔ struct via where-clause (invalid)
// // ─────────────────────────────────────────────
// 
// type Outer3 {
//     inner: Inner3
// } where {
//     type Inner3 {
//         back: Outer3
//     }
// }
// 
// 
// // ─────────────────────────────────────────────
// // 4. Union → struct → union (invalid)
// // ─────────────────────────────────────────────
// 
// type Expr4
//     | Lit4(i32)
//     | Add4(AddExpr4)
// where {
//     type AddExpr4 {
//         lhs: Expr4
//         rhs: Expr4
//     }
// }
// 
// 
// // ─────────────────────────────────────────────
// // 5. Generic container (valid by itself)
// // ─────────────────────────────────────────────
// 
// type Box5!(T) {
//     value: T
// }
// 
// 
// // ─────────────────────────────────────────────
// // 6. Template-dependent deep cycle (invalid)
// // ─────────────────────────────────────────────
// 
// type L1_6!(T) {
//     a: L2_6!(Box5!(T))
// }
// 
// type L2_6!(T) {
//     b: L3_6!(T)
// }
// 
// type L3_6!(T) {
//     c: T
// }
// 
// type Root6 {
//     x: L1_6!(Root6)
// }
// 
// 
// // ─────────────────────────────────────────────
// // 7. Mutually recursive templates (invalid)
// // ─────────────────────────────────────────────
// 
// type A7!(T) {
//     b: B7!(T)
// }
// 
// type B7!(T) {
//     c: C7!(T)
// }
// 
// type C7!(T) {
//     a: A7!(T)
// }
// 
// type Top7 {
//     v: A7!(Top7)
// }
// 
// 
// // ─────────────────────────────────────────────
// // 8. Generic + pointer indirection (valid)
// // ─────────────────────────────────────────────
// 
// type Tree8!(T) {
//     left: *Tree8!(T)
//     right: *Tree8!(T)
//     value: T
// }
// 
// type Forest8 {
//     root: Tree8!(i32)
// }
// 
// 
// // ─────────────────────────────────────────────
// // 9. Alias with where-clause adding requirements
// //    (tests alias identity vs behavior)
// // ─────────────────────────────────────────────
// 
// type Base9 {
//     x: i32
// }
// 
// type Alias9 = Base9 where {
//     type Extra9 {
//         y: Alias9
//     }
// }
// 
// 
// // ─────────────────────────────────────────────
// // 10. Invalid self-instantiating generic
// // ─────────────────────────────────────────────
// 
// type Bad10!(T) {
//     x: Bad10!(T)
// }
// 
// 
// // ─────────────────────────────────────────────
// // 11. Cross-generic value recursion via alias
// // ─────────────────────────────────────────────
// 
// type Wrap11!(T) {
//     v: T
// }
// 
// type Alias11 = Wrap11!(Alias11)
// 
// 
// // ─────────────────────────────────────────────
// // 12. Mixed valid/invalid field graph
// // ─────────────────────────────────────────────
// 
// type OkLeaf12 {
//     n: i32
// }
// 
// type BadMid12 {
//     leaf: OkLeaf12
//     back: BadTop12
// }
// 
// type BadTop12 {
//     mid: BadMid12
// }
// 
// 